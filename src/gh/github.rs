use anyhow::{Context, Result};
use serde::Deserialize;
use std::path::Path;
use std::process::Command;

#[derive(Debug, Clone)]
pub struct IssueRef {
    pub owner: String,
    pub repo: String,
    pub number: u64,
    pub clone_url: String,
}

impl IssueRef {
    pub fn parse(url: &str) -> Result<Self> {
        let url = url.trim().trim_end_matches('/');

        let stripped = url
            .strip_prefix("https://github.com/")
            .or_else(|| url.strip_prefix("http://github.com/"))
            .ok_or_else(|| anyhow::anyhow!("Not a GitHub URL: {}", url))?;

        let parts: Vec<&str> = stripped.split('/').collect();
        if parts.len() < 4 || parts[2] != "issues" {
            anyhow::bail!(
                "Expected format: https://github.com/owner/repo/issues/NUMBER, got: {}",
                url
            );
        }

        let owner = parts[0].to_string();
        let repo = parts[1].to_string();
        let number: u64 = parts[3]
            .parse()
            .with_context(|| format!("Invalid issue number: {}", parts[3]))?;

        if owner.is_empty() || repo.is_empty() {
            anyhow::bail!("Owner and repo cannot be empty");
        }

        let clone_url = format!("https://github.com/{}/{}.git", owner, repo);

        Ok(Self {
            owner,
            repo,
            number,
            clone_url,
        })
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct Issue {
    pub title: String,
    pub body: String,
    #[serde(default)]
    pub labels: Vec<IssueLabel>,
    pub state: String,
    pub number: u64,
    #[serde(rename = "url")]
    pub html_url: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct IssueLabel {
    pub name: String,
}

pub fn fetch_issue(url: &str) -> Result<Issue> {
    let output = Command::new("gh")
        .args([
            "issue",
            "view",
            url,
            "--json",
            "title,body,labels,state,number,url",
        ])
        .output()
        .context("Failed to run 'gh'. Is the GitHub CLI installed? (https://cli.github.com)")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        if stderr.contains("auth") || stderr.contains("login") {
            anyhow::bail!("GitHub CLI not authenticated. Run: gh auth login");
        }
        anyhow::bail!("gh issue view failed: {}", stderr);
    }

    let issue: Issue =
        serde_json::from_slice(&output.stdout).context("Failed to parse issue JSON from gh CLI")?;

    Ok(issue)
}

pub fn create_pr(repo_dir: &Path, issue: &Issue, branch: &str) -> Result<String> {
    let title = format!("fix: {} (#{})", issue.title, issue.number);
    let body = format!(
        "Fixes #{}\n\nAutomated fix generated by [fmm](https://github.com/srobinson/fmm) — sidecar-guided issue resolution.",
        issue.number
    );

    let output = Command::new("gh")
        .args([
            "pr", "create", "--title", &title, "--body", &body, "--head", branch,
        ])
        .current_dir(repo_dir)
        .output()
        .context("Failed to run gh pr create")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("gh pr create failed: {}", stderr);
    }

    let pr_url = String::from_utf8_lossy(&output.stdout).trim().to_string();
    Ok(pr_url)
}

pub fn preflight_check() -> Result<()> {
    let tools = [
        ("gh", "GitHub CLI (https://cli.github.com)"),
        ("git", "Git (https://git-scm.com)"),
        (
            "claude",
            "Claude CLI (https://docs.anthropic.com/en/docs/claude-code)",
        ),
    ];

    for (cmd, description) in &tools {
        let result = Command::new(cmd).arg("--version").output();
        match result {
            Ok(output) if output.status.success() => {}
            _ => anyhow::bail!("Required tool not found: {} — install {}", cmd, description),
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_valid_issue_url() {
        let r = IssueRef::parse("https://github.com/owner/repo/issues/123").unwrap();
        assert_eq!(r.owner, "owner");
        assert_eq!(r.repo, "repo");
        assert_eq!(r.number, 123);
        assert_eq!(r.clone_url, "https://github.com/owner/repo.git");
    }

    #[test]
    fn parse_url_with_trailing_slash() {
        let r = IssueRef::parse("https://github.com/owner/repo/issues/42/").unwrap();
        assert_eq!(r.number, 42);
    }

    #[test]
    fn parse_url_with_http() {
        let r = IssueRef::parse("http://github.com/foo/bar/issues/1").unwrap();
        assert_eq!(r.owner, "foo");
        assert_eq!(r.repo, "bar");
        assert_eq!(r.number, 1);
    }

    #[test]
    fn reject_non_github_url() {
        assert!(IssueRef::parse("https://gitlab.com/owner/repo/issues/1").is_err());
    }

    #[test]
    fn reject_pr_url() {
        assert!(IssueRef::parse("https://github.com/owner/repo/pull/123").is_err());
    }

    #[test]
    fn reject_repo_url_without_issue() {
        assert!(IssueRef::parse("https://github.com/owner/repo").is_err());
    }

    #[test]
    fn reject_invalid_issue_number() {
        assert!(IssueRef::parse("https://github.com/owner/repo/issues/abc").is_err());
    }

    #[test]
    fn reject_empty_segments() {
        assert!(IssueRef::parse("https://github.com//repo/issues/1").is_err());
    }

    #[test]
    fn parse_complex_owner_repo() {
        let r = IssueRef::parse("https://github.com/my-org/my-repo.js/issues/9999").unwrap();
        assert_eq!(r.owner, "my-org");
        assert_eq!(r.repo, "my-repo.js");
        assert_eq!(r.number, 9999);
    }
}
